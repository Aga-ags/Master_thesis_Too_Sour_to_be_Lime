---
title: "Data Processing"
author: "Agnieszka Kubica"
date: "`r Sys.Date()`"
output: html_document
---


# Libararies
```{r}
library(mice)
library(ggmice)
library(fitdistrplus) # fitting gamma distribution
library(tidyverse)
library(purrr)
library(terra)
library(sf)
library(obliquer)
library(RColorBrewer) # pretty colours graphs
set.seed(142)
```
# Loading data
```{r}
df_org <- read_csv("../data/ZH_nabodat_dataset_v1.0.csv")|>
  mutate(across(contains("datum"), ~ as.Date(., format = "%d.%m.%Y")))|>
  mutate(horizontbezeichnung = as.factor(horizontbezeichnung),
         ausgangsinfo_horizontbezeichnung = as.factor(ausgangsinfo_horizontbezeichnung),
         erhebungsart = as.factor(erhebungsart),
         anonymisierung = as.factor(anonymisierung))
df_org

df_soil_org<-df_org
# rename the columns to english names:
colnames(df_soil_org) <- c("id", "canton", "x", "y", "anonymization", "recording_date", "survey_number", "survey_date", "survey_type","profile_id", "horizon_number", "depth_from_cm", "depth_to_cm", "horizon_name", "initial_info_horizon_name", "humus_content_percent", "clay_percent", "silt_percent", "sand_percent",  "gravel_volume_percent", "stones_volume_percent", "lime_site", "pH_brightness", "fine_grain_size", "clay_from_initial_info_proc", "clay_to_initial_info_proc", "silt_from_initial_info_proc", "silt_to_initial_info_proc", "sand_from_initial_info_proc", "sand_to_initial_info_proc",
"skeletal_content", "skeletal_content_from_initial_info_vol_proc",
"skeletal_content_to_initial_info_vol_proc", "version", "date", "id.rec", "lime", "pH-H2O", "pH-CaCl2", "humus", "Corg", "clay", "silt")

df_soil_org <- df_soil_org|>
  mutate(horizon_number = as.factor(horizon_number))|>
  mutate(recording_year = as.numeric(format(as.Date(recording_date, format="%d/%m/%Y"),"%Y") ))
```
```{r}
colnames(df_org)
```
```{r}
# how many samples
df_soil_org|>
  dplyr::select(id)|>
  unique()|>
  nrow()

df_soil_org|>
  nrow()
  
```

# Initial data processing

There is 3904 samples in general, with multiple horaizons per sample. But in a few sites the measurements are repeated (3952 unique horizon 1 measurements). However, all of the repeated samples are also annnymized. 

```{r}
# Step 1: Identify sites with multiple profiles
multi_profile_sites <- df_soil_org %>%
  group_by(id) %>%
  summarise(n_profiles = n_distinct(profile_id)) %>%
  filter(n_profiles > 1) %>%
  pull(id)

# Step 2: Subset the dataframe to only those sites
df_soil_org %>%
  filter(id %in% multi_profile_sites)|>
  filter(anonymization == 0)
```


## Remove annonymized points
```{r}
# ploting where annonymized points are located 
df <- df_soil_org

df_sf <- st_as_sf(df, coords = c("x", "y"), crs = 2056)  

ggplot() +
  geom_sf(data = df_sf, aes(color = anonymization)) +
  labs(title = "Map of anonymization")
```

Unfortunately, the anonymized points are not equally distributed throughout the sampling place, but there is plenty of measurements around them.


Remove annonmyzation points since they are too inaccurate: 
```{r}
length(unique(df_soil_org[["id"]]))
annonymized_points <- df_soil_org|>
  filter(anonymization == 1)
length(unique(annonymized_points[["id"]]))


df_soil <- df_soil_org|>
  filter(anonymization == 0)
```
105 sites of 3904 are removed, to 3799.


```{r}
colnames(df_soil)

head(df_soil)

nrow(df_soil)
```
# Notes:
All values are in the Zurich canton


# EDA on original data
```{r}
summary(df_soil)
```


```{r}
ggplot(df_soil, aes(x = survey_date))+
geom_histogram()
ggplot(df_soil, aes(x = recording_date))+
geom_histogram()


```
The data spans from 1960 to 2000, with one point later on. All values are not from survey 1.  Survey and recording data are identical on this scale. 



# Join with agriculture land use

```{r}
areable_land_raster <- terra::rast("../data/zh_arable_land_s3.tif")
crs(areable_land_raster)  <- "epsg:2056"
```


```{r}
plot(areable_land_raster)
```
```{r}
# crs points
points_vect_soil <- vect(df_soil, geom = c("x", "y"), crs = crs(areable_land_raster))
vals <- extract(areable_land_raster, points_vect_soil)
vals

# join the raster values to soil df
df_soil_areable_value <- df_soil %>%
  mutate(ID_row = row_number()) %>%
  left_join(vals, join_by("ID_row" == "ID"))

df_soil_areable_value <- as.data.frame(df_soil_areable_value)

df_soil_arable <- df_soil_areable_value %>%
  filter(zh_arable_land_s3 == 1)|>
  dplyr::select(!c("zh_arable_land_s3", "ID_row"))
df_soil_arable
```


How many datapoints are there now?
```{r}
length(unique(df_soil_arable[["id"]]))
```
The same amount, so it was subset already. 


# Subset to relevant soil values
```{r filter_relevant_col}
df_soil_selected <- df_soil_arable |>
  dplyr::select(c("id", "x", "y", "horizon_number", "recording_year",  "depth_from_cm", "depth_to_cm", "survey_type", "lime", "lime_site") | contains("pH"))

df_soil_selected

length(unique(df_soil_selected[["id"]]))
```


## pH missings

```{r}
# plotting patterns of missingness in the pH values
plot_pattern(df_soil_selected, rotate = TRUE)

# Visualization for the paper
df_soil_selected|>
  rename(pH_site  = pH_brightness)|>
   dplyr::select(`pH-CaCl2`,`pH-H2O`, pH_site)|>
  plot_pattern(rotate = TRUE)

df_soil_selected|>
  rename(pH_site  = pH_brightness)|>
   dplyr::select(lime, lime_site)|>
  plot_pattern(rotate = TRUE)

```


```{r}
# from the original dataframe (with annonymized points) we can see that the relationships between site pH and CaCl2 is quite 1:1, with a small number of outliers.
ggplot(data = df_soil_org, aes(x = `pH-CaCl2`, y = pH_brightness))+
  geom_point()+
  geom_abline(slope = 1, intercept = 0)+
  theme_minimal()+
  labs(x ="pH CaCl2", y = "site pH")
  
ggsave(file = "../Figures/site_lab_relationship_plot.pdf")

# Finding just how many points have been plotted
df_soil_org|>
  dplyr::select(`pH-CaCl2`, pH_brightness)|>
  filter((!is.na(`pH-CaCl2`)) & (!is.na(`pH_brightness`)))|>
  nrow()
```


```{r}
# Uncertaintity of 1 - 1 impuatation of site pH into CaCl2:

correlation_pH <- cor(df_soil_org$pH_brightness, df_soil_org$`pH-CaCl2`, use = "complete.obs")
correlation_pH

pred_Ca_check <- df_soil_org|>
  filter(!is.na(`pH-CaCl2`) & !is.na(pH_brightness))|>
  dplyr::select(`pH-CaCl2`, pH_brightness)

rmse <- sqrt(mean((pred_Ca_check$`pH-CaCl2` - pred_Ca_check$pH_brightness)^2))
rmse

```
On average the actual pH is 0.57 away from the site measure 

## Convert pH-H2O and site pH into pH-CaCl2
```{r missing_pattern_pH,  fig.width = 14 fig.height=5}
df_soil_selected_pH_conv <- df_soil_selected|>
  # CaCl2 is missing, try imputing from H2O
  mutate(`pH_CaCl2_imputed` = ifelse(is.na(`pH-CaCl2`), ifelse(is.na(`pH-H2O`), NA, `pH-H2O` - 0.7) ,`pH-CaCl2`), 
  # CaCl2 is still missing, try imputing from site pH
         `pH_CaCl2_imputed` = ifelse(is.na(`pH_CaCl2_imputed`), ifelse(is.na(pH_brightness), NA, pH_brightness) ,`pH_CaCl2_imputed`),
  # make a new column indicating origin of pH value
         pH_origin = as.factor(ifelse(is.na(`pH-CaCl2`), ifelse(is.na(`pH-H2O`), ifelse(is.na(`pH_brightness`), NA, "site"), "H2O") , "CaCl2")))

df_soil_selected_pH_conv|>
  dplyr::select(where(~ anyNA(.))) |>
  plot_pattern(rotate = TRUE)

df_soil_selected_pH_conv|>
  dplyr::select(where(~ anyNA(.))) |>
  dplyr::select("pH_CaCl2_imputed", "lime", "lime_site")|>
  plot_pattern(rotate = TRUE)
```
Extra 1249 pH measurements, to a total of 6879. In terms of sites that translates to: 

```{r}
df_soil_selected_pH_conv|>
  mutate(lime_mis = is.na(lime_site))|>
ggplot(aes(x = lime_mis, y = pH_CaCl2_imputed))+
  geom_point()
```

```{r}
# relationship between lime in lab and site
df_soil_selected_pH_conv|>
  ggplot(aes(x = lime, y = lime_site))+
  geom_point()
```

```{r}
# pH and lime relationship in sample
df_soil_selected_pH_conv|>
  ggplot(aes(x = pH_CaCl2_imputed, y = lime_site))+
  geom_point()

df_soil_selected_pH_conv|>
  ggplot(aes(x = pH_CaCl2_imputed, y = lime, colour = pH_origin, alpha = 0.5))+
  geom_point()

df_soil_selected_pH_conv|>
  ggplot(aes(x = pH_CaCl2_imputed, y = lime))+
  geom_bin2d()

df_soil_selected_pH_conv|>
  mutate(lime_mis = is.na(lime))|>
  filter(pH_CaCl2_imputed <6.5 & lime_mis == TRUE)|>
  nrow()
df_soil_selected_pH_conv|>
  mutate(lime_mis = is.na(lime))|>
  filter(pH_CaCl2_imputed <6 & lime_mis == TRUE)|>
  nrow()

df_soil_selected_pH_conv|>
  dplyr::select(where(~ anyNA(.))) |>
  dplyr::select("pH_CaCl2_imputed", "lime", "lime_site")|>
  filter(pH_CaCl2_imputed >=6)|>
  plot_pattern(rotate = TRUE)
df_soil_selected_pH_conv|>
  dplyr::select(where(~ anyNA(.))) |>
  dplyr::select("pH_CaCl2_imputed", "lime", "lime_site")|>
  filter(pH_CaCl2_imputed >=6.5)|>
  plot_pattern(rotate = TRUE)
```
# pH and lime relationships in entire Switzerland 
```{r}
# load entirety of Switzerland
df_swiss <- read_csv("../data/CH_SamplesArableLand_V2.csv")|>
  mutate(across(contains("datum"), ~ as.Date(., format = "%d.%m.%Y")))|>
  mutate(horizontbezeichnung = as.factor(horizontbezeichnung),
         ausgangsinfo_horizontbezeichnung = as.factor(ausgangsinfo_horizontbezeichnung),
         erhebungsart = as.factor(erhebungsart),
         anonymisierung = as.factor(anonymisierung))|>
  rename(
    lime = Kalk,
    lime_site = kalk_caco3,
    pH_brightness = ph_hellige
  )
df_swiss


df_swiss <- df_swiss|>
# convert pH's into one
  # CaCl2 is missing, try imputing from H2O
  mutate(`pH_CaCl2_imputed` = ifelse(is.na(`pH-CaCl2`), ifelse(is.na(`pH-H2O`), NA, `pH-H2O` - 0.7) ,`pH-CaCl2`), 
  # CaCl2 is still missing, try imputing from site pH
         `pH_CaCl2_imputed` = ifelse(is.na(`pH_CaCl2_imputed`), ifelse(is.na(pH_brightness), NA, pH_brightness) ,`pH_CaCl2_imputed`),
  # make a new column indicating origin of pH value
         pH_origin = as.factor(ifelse(is.na(`pH-CaCl2`), ifelse(is.na(`pH-H2O`), ifelse(is.na(`pH_brightness`), NA, "site"), "H2O") , "CaCl2")),
  lime_site = as.factor(lime_site))|>
    dplyr::select(c("lime", "lime_site", "pH_CaCl2_imputed", "pH_origin"))

df_swiss
```
```{r}

ggplot(df_swiss, aes(x = pH_CaCl2_imputed))+
  geom_boxplot()

df_swiss <- df_swiss|>
  filter(pH_CaCl2_imputed < 15)

ggplot(df_swiss, aes(x = pH_CaCl2_imputed, fill = pH_origin))+
  geom_histogram()


```

```{r vizualize_lime_pH_in_Switzerland}
# lab lime and pH
df_swiss|>
  ggplot(aes(x = pH_CaCl2_imputed, y = lime, colour = pH_origin))+
  geom_point(alpha = 0.2)+
  geom_vline(xintercept = 6.5)+
  geom_vline(xintercept = 6)+
  theme_minimal()+
  labs(x ="Imputed pH", y = "Laboratory lime content", colour = "Origin of pH value")+
  annotate("text", x = 6.15, y = 110, label = "6") +
  annotate("text", x = 6.8, y = 110, label = "6.5")

ggsave(file = "../Figures/lime_ph_switzerland_relationship_plot.pdf")


```
```{r vizualize_lime_pH_in_Switzerland_2}
# Observed relationship between lime classes and lab lime

df_swiss|>
  filter(!is.na(lime_site))|>
  ggplot(aes(y = lime, x = lime_site))+
  geom_boxplot()+
  theme_minimal()+
  labs(x ="Site lime classification", y = "Laboratory lime content")

ggsave(file = "../Figures/lime_site_lab_lime_switzerland_histograms.pdf")

```

```{r vizualize_lime_pH_in_Switzerland_3}
df_swiss|>
  ggplot(aes(x = pH_CaCl2_imputed, y = lime))+
  geom_bin2d(bins = 70) +
  geom_vline(xintercept = 6.5)+
  geom_vline(xintercept = 6)+
  scale_fill_continuous(type = "viridis")+
  theme_minimal()

df_swiss|>
  filter(pH_CaCl2_imputed < 6.5)|>
  ggplot(aes(x = lime))+
  geom_histogram()+
  ggtitle("Distribution of lime for pH below 6.5")

df_swiss|>
  filter(pH_CaCl2_imputed < 6.5)|>
  ggplot(aes(x = lime))+
  geom_boxplot()+
  ggtitle("Distribution of lime for pH below 6.5")

# lime classes and pH

df_swiss|>
  ggplot(aes(y = pH_CaCl2_imputed, x = lime_site))+
  geom_boxplot()+
  geom_hline(yintercept = 6.5)

# distribution of lime
df_swiss|>
  filter(lime_site %in% c("3", "4", "5"))|>
  ggplot(aes(x = lime))+
  geom_histogram()+
  facet_wrap(vars(lime_site))

```


```{r remove_outliers}
# Remove outliers classes 3,4 and 5. 

remove_outliers_per_class <- function(class, lower_percentage, higher_percentage){
df_selected_middle <- df_swiss|>
  filter(lime_site == class & ! is.na(lime))|>
  dplyr::select(lime)|>
  filter(lime > quantile(lime, lower_percentage) & lime < quantile(lime, higher_percentage))

return(df_selected_middle)
}

df_lime_3 <- remove_outliers_per_class(class = 3, lower_percentage = 0.1, higher_percentage = 0.9)
df_lime_4 <- remove_outliers_per_class(class = 4, lower_percentage = 0.1, higher_percentage = 0.9)
df_lime_5 <- remove_outliers_per_class(class = 5, lower_percentage = 0.1, higher_percentage = 0.9)
```


# impute lime
```{r impute_lime}
# distribution of lime pre imputation
df_soil_selected_pH_conv|>
  ggplot(aes(x = lime))+
  geom_histogram()

# impute lime from pH and classes 0-2
df_soil_selected_pH_conv <- df_soil_selected_pH_conv|>
  mutate(
    # this indication of whether lime is imputed is okey, because all values that will stay NA will be removed later on
    lime_imputed = is.na(lime),
    # is pH below 6.5:
    lime = ifelse (pH_CaCl2_imputed < 6.5 & is.na(lime), 0, lime),
    # lime_site < 3
    lime_imputed_0_2 = is.na(lime) & !is.na(lime_site) & lime_site < 3,
    lime = ifelse(is.na(lime) & !is.na(lime_site) & lime_site < 3, 0, lime))

# Imputation based on classes 3,4,5 

# Size of sample that needs to be taken:
length_impute_class_3 <- df_soil_selected_pH_conv|>
  filter(is.na(lime) & lime_site == 3)|>
  nrow()
length_impute_class_4 <- df_soil_selected_pH_conv|>
  filter(is.na(lime) & lime_site == 4)|>
  nrow()
length_impute_class_5 <- df_soil_selected_pH_conv|>
  filter(is.na(lime) & lime_site == 5)|>
  nrow()

# Imputing the missing values:
df_soil_selected_pH_conv <- df_soil_selected_pH_conv|>
  # lime_site = 3
  mutate(
    lime_imputed_3_5 = is.na(lime), 
    lime = ifelse(is.na(lime)& !is.na(lime_site) & lime_site == 3, 
                       # randomly draw from oberved values in Switzerland (without outliers)
                       sample(df_lime_3$lime, size = length_impute_class_3, replace = TRUE), 
                       # lime_site = 4
                       ifelse(is.na(lime)& !is.na(lime_site) & lime_site == 4, 
                              sample(df_lime_4$lime, size = length_impute_class_4, replace = TRUE),
                              # lime_site = 5
                               ifelse(is.na(lime)& !is.na(lime_site) & lime_site == 5, 
                                      sample(df_lime_5$lime, size = length_impute_class_5, replace = TRUE),
                                      lime))))
                                  
# post visualization: 

df_soil_selected_pH_conv|>
  ggplot(aes(x = pH_CaCl2_imputed, y = lime))+
  geom_point(alpha = 0.5)

df_soil_selected_pH_conv|>
  ggplot(aes(x = lime, fill = lime_imputed))+
  geom_histogram()

# The missingness of pH and lime post imputation
df_soil_selected_pH_conv|>
  dplyr::select("pH_CaCl2_imputed", "lime", "lime_site", "lime_imputed")|>
  plot_pattern(rotate = TRUE)

```



```{r}
# remove rows with missing lime
df_soil_selected_pH_conv <- df_soil_selected_pH_conv|>
  filter(!is.na(lime))|>
  dplyr::select(-lime_site)
df_soil_selected_pH_conv
```

```{r quantify_imp_lime}
# Quantify how much of each imputation occurred

print("Number of horizons imputed from pH < 6.5:")
df_soil_selected_pH_conv|> 
  filter(lime_imputed == TRUE & lime_imputed_0_2 == FALSE & lime_imputed_3_5 == FALSE)|>
  nrow()

print("Number of horizons imputed from lime class 0-2:")
df_soil_selected_pH_conv|> 
  filter(lime_imputed_0_2 == TRUE )|>
  nrow()

print("Number of horizons imputed from lime class 3-5:")
df_soil_selected_pH_conv|> 
  filter(lime_imputed_3_5 == TRUE)|>
  nrow()

print("Number of horizons with oberved lime")

df_soil_selected_pH_conv|> 
  filter(!is.na(lime))|>
  nrow()

df_soil_selected_pH_conv|> 
  filter(!is.na(lime) & lime_imputed== FALSE)|>
  nrow()
```


```{r}
missing_ph_df <- df_soil_selected_pH_conv|>
  group_by(id)|> 
  mutate(pH_is_fully_na = is.na(pH_CaCl2_imputed),
         site_ph_na = is.na(pH_brightness), 
         h20_ph_na = is.na(`pH-H2O`), 
         cacl2_ph_na = is.na(`pH-CaCl2`))
```


```{r}
# Plotting missingness of pH

ggplot(missing_ph_df, aes(x = recording_year, fill = pH_origin))+ 
  geom_histogram(stat="count")+ theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
# H20 collected exclusively in 1974 and 1975, starting from 1977 it is CaCl2, not lab pH earlier

ggplot(missing_ph_df, aes(x = survey_type, fill = pH_origin))+ 
  geom_bar(stat="count")+ 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
# lab results of pH come only from C type surveys, the other only record site pH
ggplot(missing_ph_df, aes(x = recording_year, fill = survey_type))+ 
  geom_bar(stat="count")+ 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))


ggplot(missing_ph_df, aes(x = horizon_number, fill = pH_is_fully_na))+ 
  geom_bar(stat="count", position="fill")+ 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
# The amount of missing pH grows with horizons (or rather deph) because more material in which pH cannot be measured is encountered at lower horizons


# Missingness of pH over time
ggplot(missing_ph_df, aes(x = recording_year, fill = pH_is_fully_na))+ 
  geom_histogram(stat="count")+ 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

ggplot(missing_ph_df, aes(x = recording_year, fill = pH_is_fully_na))+ 
   geom_bar( position="fill")+ 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
# There seems to be no specific trend in missingness over time

```
```{r}
missing_ph_df|> 
  filter(survey_type == "U") 
missing_ph_df|> 
  filter(survey_type == "P") 
```
So, U only does site pH, while P H20 and site. 

# Ploting lime (all)
```{r}

ggplot(missing_ph_df, aes(x = recording_year, y = lime))+ 
  geom_point()

ggplot(missing_ph_df, aes(x = lime))+ 
  geom_histogram()
```

# Ploting pH (all)
```{r}

ggplot(missing_ph_df, aes(x = recording_year, y = pH_CaCl2_imputed))+ 
  geom_point()

ggplot(missing_ph_df, aes(x = pH_CaCl2_imputed))+ 
  geom_histogram()
```

# spatial distribution of pH and pH missingness (all pH)
```{r}

df_sf <- st_as_sf(missing_ph_df, coords = c("x", "y"), crs = 2056)  


ggplot() +
  geom_sf(data = df_sf, aes(color = pH_is_fully_na, alpha = 0.3)) +
  labs(title = "Map of missing pH")

df_sf|>
  filter(pH_is_fully_na == FALSE)|>
ggplot() +
  geom_sf(aes(color = pH_CaCl2_imputed,  alpha = 0.3)) +
  labs(title = "Map of pH values")+
  scale_colour_distiller(palette ="RdBu")
```


# Select relevant soil variables
```{r}
# save current format for sf figures (an the end of this script)
df_map <- df_soil_selected_pH_conv
df_map

# removing other pH's
df_soil_selected_pH_conv <- df_soil_selected_pH_conv%>%
  dplyr::select(!c("pH-H2O", "pH-CaCl2", "pH_brightness", "horizon_number", "survey_type"))

# removing still missing pH and lime sites
df_soil_selected_pH_conv <- df_soil_selected_pH_conv%>%
  filter(!is.na(pH_CaCl2_imputed) & !is.na(lime))|>
  rename(pH = pH_CaCl2_imputed)

df_soil_selected_pH_conv
length(unique(df_soil_selected_pH_conv[["id"]])) 
```

```{r plotting_ditribution_final_outputs}
df_lime_dist <- df_soil_selected_pH_conv|>
  mutate(lime_origin = ifelse(lime_imputed_3_5 == TRUE, "Classes 3-5",
         ifelse(lime_imputed_0_2 == TRUE, "Classes 0-2",
                ifelse(lime_imputed_3_5 == FALSE & lime_imputed_0_2 == FALSE & lime_imputed == FALSE, "Laboratory lime content", "pH <6.5"))))

df_lime_dist$lime_origin<-ordered(df_lime_dist$lime_origin, levels =c("Laboratory lime content", "pH <6.5", "Classes 0-2", "Classes 3-5"))

  ggplot(df_lime_dist, aes(x = lime, fill = lime_origin))+ 
  geom_histogram(bins = 30)+
  theme_minimal()+
  labs(x = "Lime content", y = "Count",  fill = "Origin of lime value")+
    scale_fill_brewer(palette = "Dark2")
ggsave(file = "../Figures/distribution_lime.pdf")

ggplot(df_soil_selected_pH_conv, aes(x = pH, fill = pH_origin))+ 
  geom_histogram()+
  theme_minimal()+
  labs(x = "pH", y = "Count", fill = "Origin of pH value") 
ggsave(file = "../Figures/distribution_pH.pdf")
```



# Join with covariates 
```{r}
# points data

df_soil_with_cov <- df_soil_selected_pH_conv%>%
  mutate(ID_row = row_number())

points_arable_soil <- vect(df_soil_with_cov, geom = c("x", "y"), crs = crs(areable_land_raster))

points_arable_soil
```



```{r}
# Set main folder path
main_folder <- "../data/covariates/"

# Get list of all .tif files in subfolders
tif_files <- list.files(main_folder, pattern = "\\.tif$", recursive = TRUE, full.names = TRUE)

# Apply function to each file
join_covariates <- function(tif_file){
  #load raster
  raster_file <- terra::rast(tif_file)
  crs(raster_file)  <- "epsg:2056"
  
  #extract values
  vals <- extract(raster_file, points_arable_soil)
  
  # join the raster values to soil df
  df_soil_with_cov <- df_soil_with_cov %>%
  left_join(vals, join_by("ID_row" == "ID"))
  
  # if the file contains categorical -> mutate last column as factor
  if (grepl("categoric", tif_file)) {
  last_col_name <- names(df_soil_with_cov)[ncol(df_soil_with_cov)]
  df_soil_with_cov <- df_soil_with_cov %>%
    mutate(!!sym(last_col_name) := as.factor(.data[[last_col_name]]))
  }
  return(df_soil_with_cov)
}

for (file in tif_files) {
  df_soil_with_cov <- join_covariates(file)
}

df_soil_with_cov<- df_soil_with_cov|>
  dplyr::select(-ID_row)


```

```{r}
df_soil_with_cov
```

# EDA 

## Missing data in covariates


```{r quantifing_missing_covariates}
df_soil_with_cov %>%
  dplyr::select(where(~ anyNA(.))) %>%
  dplyr::select(! contains("pH")) %>%
  md.pattern(plot = TRUE, rotate.names = TRUE )

# How many locations are missing each covariate
df_soil_with_cov|>
  filter(is.na(drainfor))|>
  distinct(x, y)|>
  nrow()

df_soil_with_cov|>
  filter(is.na(feucht_wild))|>
  distinct(x, y)|>
  nrow()

df_soil_with_cov|>
  filter(is.na(bedgwleiter))|>
  distinct(x, y)|>
  nrow()

df_soil_with_cov|>
  filter(is.na(gwleiter))|>
  distinct(x, y)|>
  nrow()

df_soil_with_cov|>
  filter(is.na(skfeucht))|>
  distinct(x, y)|>
  nrow()
```
There is missingness among 5 covariates:  drainfor, feucht_wild, bedgwleiter, gwleiter, skfeucht. - the last 3 are maps that should be complete? Open maps, see what happens. Most liekly can be imputed if we find why is it missing - maybe nearest neighbor can work. 

```{r}
cov_missing_sf <- df_soil_with_cov|>
  st_as_sf(coords = c("x", "y"), crs = 2056)  


ggplot() +
  geom_sf(data = cov_missing_sf, aes(color = is.na(drainfor), alpha = 0.3)) 


ggplot() +
  geom_sf(data = cov_missing_sf, aes(color = is.na(feucht_wild), alpha = 0.3)) 


ggplot() +
  geom_sf(data = cov_missing_sf, aes(color = is.na(bedgwleiter), alpha = 0.3)) 

ggplot() +
  geom_sf(data = cov_missing_sf, aes(color = is.na(gwleiter), alpha = 0.3)) 


ggplot() +
  geom_sf(data = cov_missing_sf, aes(color = is.na(skfeucht), alpha = 0.3)) 

```
Investigating the tiffs with missing data:

```{r}
# Set main folder path
main_folder <- "../data/covariates/"

mis_cov <- list("drainfor", "feucht_wild", "bedgwleiter", "gwleiter", "skfeucht")


for (cov in mis_cov) {
  tif_file <- paste0(main_folder, ifelse(cov == "drainfor", "numeric/", "categoric/"), cov, ".tif")
  raster_file <- terra::rast(tif_file)
  crs(raster_file) <- "epsg:2056"
  
  df_here <- df_soil_with_cov
  
  # Check which points are missing for this covariate
  df_here$is_missing <- is.na(df_here[[cov]])
  
  df_here <- df_here|>
    filter(is_missing == TRUE)
  
  # Convert to sf object
  cov_missing_sf <- df_here |>
    st_as_sf(coords = c("x", "y"), crs = 2056)
  
  # Plot raster
  plot(raster_file, main = cov)
  
  # Add points, coloring by missingness
  plot(st_geometry(cov_missing_sf), 
       add = TRUE, 
       col = ifelse(cov_missing_sf$is_missing, "red", "blue"), 
       pch = 16)
  
  legend("topright", legend = c("Missing", "Present"), col = c("red", "blue"), pch = 16)
}

```

So, drainfor is kind of randomly missing even though the entire raster is complete. 
For feucht_wild and bedgwleiter - the raster is smaller than the bounding box of the studied points. 
For gwleiter and skfeucht - there are NA values everywhere beyond the aquifers/moist areas, for the former I am not quite sure what to impute, for the latter just a 0 should be sufficient. 


```{r imp_skflucht_and_gwleiter}
# imputing the covariates
df_soil_with_cov <- df_soil_with_cov|>
  mutate(skfeucht = ifelse(is.na(skfeucht), 0, skfeucht),
         gwleiter = ifelse(is.na(gwleiter), 0, gwleiter),
         feucht_wild =  ifelse(is.na(feucht_wild), 0, feucht_wild), 
          bedgwleiter  = ifelse(is.na(bedgwleiter), 0, bedgwleiter))
```

```{r imp_drainfor}
# impute drainfor

points_sf <- df_soil_with_cov |>
    st_as_sf(coords = c("x", "y"), crs = 2056)

#raster file
raster_file <- paste0(main_folder,  "numeric/", "drainfor", ".tif")
raster_file <- terra::rast(raster_file)
crs(raster_file) <- "epsg:2056"

# Extract raster values at points
point_vals <- terra::extract(raster_file, points_sf)

# Identify missing indices
missing_idx <- which(is.na(point_vals[[2]]))  # assuming second column holds the raster value

# Get non-NA raster cells and their coordinates
non_na_cells <- which(!is.na(values(raster_file)))
non_na_coords <- xyFromCell(raster_file, non_na_cells)
non_na_values <- values(raster_file)[non_na_cells]

# Initialize imputed values vector
imputed_values <- point_vals[[2]]

for (i in missing_idx) {
  # Get point coordinates
  pt_coord <- st_coordinates(points_sf[i, ])
  
  # Compute distances to non-NA cells
  dists <- sqrt((non_na_coords[,1] - pt_coord[1])^2 + (non_na_coords[,2] - pt_coord[2])^2)
  
  # Filter by radius (≤ 1000 units)
  within_radius_idx <- which(dists <= 1000)
  
  if (length(within_radius_idx) > 0) {
    # Impute using median of values within radius
    imputed_values[i] <- median(non_na_values[within_radius_idx], na.rm = TRUE)
  } else {
    # Optional: if no neighbor within radius, leave as NA or use closest
    closest_idx <- which.min(dists)
    imputed_values[i] <- non_na_values[closest_idx]
  }
}

# Add imputed values to points
points_sf$imputed_raster_value <- imputed_values

# Add the imputed values to original column
points_sf <- points_sf|>
  mutate(drainfor = ifelse(is.na(drainfor), imputed_raster_value, drainfor))|>
  dplyr::select(!c("imputed_raster_value"))

no_geometry <- points_sf %>%
  st_drop_geometry()

df_soil_with_cov <- cbind(no_geometry, data.frame(st_coordinates(points_sf[,1])))
```



```{r}
df_soil_with_cov %>%
  dplyr::select(! contains("pH")) %>%
  md.pattern(plot = FALSE, rotate.names = TRUE )
```

## Distributions

```{r}
colnames(df_soil_with_cov)
```

```{r}

make_histograms <- function(df, variables_range){
  df %>%
  keep(is.numeric) %>% 
  dplyr::select(! contains("pH")) %>%
  dplyr::select(! contains("id")) %>%
  dplyr::select(all_of(variables_range)) %>%
  gather() %>% 
  ggplot(aes(value)) +
    facet_wrap(~ key, scales = "free") +
    geom_histogram()
}

make_histograms(df_soil_with_cov, 1:25)
make_histograms(df_soil_with_cov, 25:45)
make_histograms(df_soil_with_cov, 45:65)
make_histograms(df_soil_with_cov, 65:72)

```

Both right skewed, left skewed and normal distributions. No drastic distributions. 

```{r}
# Identify all factor columns
factor_cols <- df_soil_with_cov %>% keep((is.factor)) %>% names()

# Loop over factor columns and plot
for (col in factor_cols) {
  p <- ggplot(df_soil_with_cov, aes(x = .data[[col]])) +
    geom_bar(fill = "steelblue") +
    labs(title = paste("Distribution of", col), x = col, y = "Count") +
    theme_minimal()
  
  print(p)  # Show plot
}
```

## Correlations
```{r correlation_plot, fig.width = 14}
# Define your target variable
target_var <- "pH"

# Select numeric variables
numeric_df <- df_soil_with_cov %>% dplyr::select(where(is.numeric))

# Compute correlations
correlations <- numeric_df %>%
  dplyr::select(-all_of(target_var)) %>%
  summarise(across(everything(), ~ cor(.x, numeric_df[[target_var]], use = "complete.obs"))) %>%
  pivot_longer(everything(), names_to = "variable", values_to = "correlation")

# Plot correlations
ggplot(correlations, aes(x = reorder(variable, correlation), y = correlation)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +
  labs(title = paste("Correlation of", target_var, "with Other Variables"),
       x = "Variable", y = "Correlation") +
  theme_minimal()
```


## Add oblique geographic coordinates

Used source to cite: https://github.com/anbm-dk/obliquer/blob/main/README.md 

```{r OBCs}
# creating the oblique geographic coordinates based on a raster

my_cov <- terra::rast("../data/covariates/numeric/drumdist.tif")#terra Spat Raster
crs(my_cov) <- "EPSG:2056"
ogcs <- obliquify(my_cov, 10) #drastic increase in prediction performace stoped around here for most models
ogcs
```

```{r}
# add the OBCs to dataframe
points_for_rotation <- df_soil_with_cov|>
  vect(geom = c("X", "Y"), crs = "EPSG:2056")

data_with_OBCs <- extract(ogcs, points_for_rotation, bind = TRUE)
data_with_OBCs_values <- values(data_with_OBCs)

data_with_OBCs

```



```{r}
#add standard coordinates to make plotting easier
processed_data <- cbind(data_with_OBCs_values, crds(data_with_OBCs, df=TRUE, list=FALSE))
```



## Point values at depths

```{r}
# Convert depth_from_cm, depth_to_cm to depth (including from, to and average) column per site
processed_data <- processed_data |>
  mutate(depth_avr = (depth_from_cm + depth_to_cm)/2)|>
  pivot_longer(cols = c("depth_avr", "depth_to_cm", "depth_from_cm"), 
               names_to = "type_depth", 
               values_to = "depth")|>
  dplyr::select(-"type_depth", -"id")|>
  #change order of columns
  dplyr::select("pH", "pH_origin", "depth", "x", "y", "lime", "lime_imputed", "lime_imputed_3_5", "lime_imputed_0_2", "recording_year", everything())

processed_data
```


## standardize all continious variables

```{r}
# Create an empty data frame to store mean and sd
scaling_params <- data.frame(
  variable = character(),
  mean = numeric(),
  sd = numeric(),
  stringsAsFactors = FALSE
)

# Define the variables to scale
vars_to_scale <- processed_data %>%
  dplyr::select(where(is.numeric), -any_of(c("x", "y", "id"))) %>%
  names()

# Scale variables and store mean/sd
for (var in vars_to_scale) {
  scaled_values <- scale(processed_data[[var]])
  
  # Overwrite the column with scaled values
  processed_data[[var]] <- as.numeric(scaled_values)
  
  # Extract mean and sd from attributes
  var_mean <- attr(scaled_values, "scaled:center")
  var_sd <- attr(scaled_values, "scaled:scale")
  
  # Add to the results dataframe
  scaling_params <- rbind(
    scaling_params,
    data.frame(variable = var, mean = var_mean, sd = var_sd)
  )
}

processed_data <- as.data.frame(processed_data)
# Results
print(scaling_params)
print(processed_data)

# Optional: write to CSV
write.csv(scaling_params, "scaling_parameters.csv", row.names = FALSE)

```

```{r}
ph_mean <- scaling_parameters$mean[scaling_parameters$variable=="pH"]
ph_std <- scaling_parameters$sd[scaling_parameters$variable=="pH"]
lime_mean <- scaling_parameters$mean[scaling_parameters$variable=="lime"]
lime_std <- scaling_parameters$sd[scaling_parameters$variable=="lime"]

ph_mean
ph_std
lime_mean
lime_std

(6.5 - ph_mean) / ph_std
(0 - lime_mean) / lime_std
```


```{r}
ggplot(processed_data, aes(x = lime))+
  geom_histogram()

ggplot(processed_data, aes(x = pH))+
  geom_histogram()
```


## Save the data
```{r}
complete_df <- processed_data[complete.cases(processed_data), ]
colnames(complete_df)
complete_df
```

```{r}
write.csv(complete_df,file='../data/processed_data.csv', row.names=FALSE)
saveRDS(complete_df, file="../data/processed_data.Rda")
saveRDS(df_soil_arable, file="../data/arable_samples_all.Rda")
```


# Create a table of imputation scenarios
```{r}
print("No lime imp | No pH imp | ph h20 | ph site")

complete_df|>
  filter(lime_imputed== FALSE & pH_origin == "CaCl2")|>
  nrow()
complete_df|>
  filter(lime_imputed== FALSE & pH_origin %in% c("CaCl2", "H2O"))|>
  nrow()
complete_df|>
  filter(lime_imputed== FALSE)|>
  nrow()

print("Lime from pH <6.5 | No pH imp | ph h20 | ph site")
complete_df|>
  filter(lime_imputed_0_2 == FALSE & lime_imputed_3_5 == FALSE) |>
  filter(pH_origin == "CaCl2")|>
  nrow()

complete_df|>
  filter(lime_imputed_0_2 == FALSE & lime_imputed_3_5 == FALSE) |>
  filter(pH_origin %in% c("CaCl2", "H2O"))|>
  nrow()

complete_df|>
  filter(lime_imputed_0_2 == FALSE & lime_imputed_3_5 == FALSE) |>
  nrow()

print("Lime from 0-2 | No pH imp | ph h20 | ph site")

complete_df|>
  filter(lime_imputed_3_5 == FALSE) |>
  filter(pH_origin == "CaCl2")|>
  nrow()

complete_df|>
  filter(lime_imputed_3_5 == FALSE) |>
  filter(pH_origin %in% c("CaCl2", "H2O"))|>
  nrow()

complete_df|>
  filter(lime_imputed_3_5 == FALSE) |>
  nrow()

print("Lime from 3-5 | No pH imp | ph h20 | ph site")

complete_df|>
  filter(pH_origin == "CaCl2")|>
  nrow()

complete_df|>
  filter(pH_origin %in% c("CaCl2", "H2O"))|>
  nrow()

complete_df|>
  nrow()

```



# Create vectors of datapoints for maps:

```{r all_available_points}
# Extract all points in arable land that were available for analysis, will be colored by if they ended up in the final data

# Extract which locations are included in the analysis from final dataframe
locations_of_points_in_analysis <- complete_df |>
  dplyr::select(x,y)|>
  distinct()
locations_of_points_in_analysis$in_analysis <- 1

  complete_df|>
  distinct(x, y)|>
  nrow()

# Find which of the original data are included in the analysis:
all_arable_points_with_inclusion_variable <- df_soil_org |>
  dplyr::select(x, y, horizon_number)|>
  left_join(y = locations_of_points_in_analysis, by = c("x", "y"))|>
  filter(horizon_number == 1)|>
  mutate(in_analysis = ifelse(is.na(in_analysis), 0, in_analysis))

# Convert the dataframe to sf object
crs <- "epsg:2056"
all_arable_points_with_inclusion_variable_sf <- st_as_sf(x = all_arable_points_with_inclusion_variable,                         
           coords = c("x", "y"),
           crs = crs)
# Save the sf object as shapefile
st_write(all_arable_points_with_inclusion_variable_sf, "../data/all_arable_points_with_inclusion_variable.shp", append=FALSE)
```

```{r sf_distribution_of_lime_and_pH}
# Extract all points in arable land that were available for analysis with imputed pH and lime, will be shaped by origin of the values
df_map2 <- df_map |>
  mutate(lime_origin = ifelse(lime_imputed == FALSE, 0,
                              ifelse(lime_imputed_0_2 == TRUE, 2,
                                     ifelse(lime_imputed_3_5 == TRUE, 3,1))))|>
  dplyr::select(x,y, horizon_number, lime, pH_CaCl2_imputed, pH_origin, lime_origin)|>
  filter(horizon_number == 1)

df_map2<- df_map2[complete.cases(df_map2), ]
df_map2

# Convert the dataframe to sf object
crs <- "epsg:2056"
df_map2 <- st_as_sf(x = df_map2,                         
           coords = c("x", "y"),
           crs = crs)
# Save the sf object as shapefile
st_write(df_map2, "../data/pH_lime_horizon_1_points.shp", append=FALSE)

```


